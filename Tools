#!/usr/bin/env bash

#
# 多功能脚本工具箱框架 (灵感来源: kejilion.sh)
#

# 遇到任何错误则终止脚本 (在函数内部按需使用)
# set -e

# --- 颜色定义 ---
# 使用 tput 动态获取颜色代码，兼容性更好
if command -v tput >/dev/null 2>&1 && [[ $(tput colors) -ge 8 ]]; then
  C_RESET=$(tput sgr0)
  C_RED=$(tput setaf 1)
  C_GREEN=$(tput setaf 2)
  C_YELLOW=$(tput setaf 3)
  C_BLUE=$(tput setaf 4)
  C_CYAN=$(tput setaf 6)
else
  # 如果 tput 不可用，则使用静态代码
  C_RESET='\033[0m'
  C_RED='\033[0;31m'
  C_GREEN='\033[0;32m'
  C_YELLOW='\033[0;33m'
  C_BLUE='\033[0;34m'
  C_CYAN='\033[0;36m'
fi

# --- 辅助函数 ---

# 功能完成后暂停，等待用户按任意键继续
function press_any_key_to_continue() {
  echo -e "\n${C_YELLOW}按任意键返回主菜单...${C_RESET}"
  # read a single character
  read -n 1 -s -r
}

# --- 功能函数定义 ---
# 这里是每个菜单选项对应的具体功能实现

# 1. 系统信息查询
function show_system_info() {
  clear
  echo -e "${C_CYAN}======== 系统信息查询 ========${C_RESET}"
  echo -e "主机名: ${C_GREEN}$(hostname)${C_RESET}"
  echo -e "操作系统: ${C_GREEN}$(source /etc/os-release && echo $PRETTY_NAME)${C_RESET}"
  echo -e "内核版本: ${C_GREEN}$(uname -r)${C_RESET}"
  echo -e "CPU型号: ${C_GREEN}$(grep "model name" /proc/cpuinfo | head -n1 | cut -d: -f2)${C_RESET}"
  echo -e "内存使用: ${C_GREEN}$(free -h | awk '/^Mem/ {print $3 "/" $2}')${C_RESET}"
  echo -e "硬盘使用: ${C_GREEN}$(df -h / | awk 'NR==2 {print $3 "/" $2 " (" $5 ")"}') ${C_RESET}"
  echo -e "公网IP: ${C_GREEN}$(curl -s ip.sb)${C_RESET}"
  echo -e "${C_CYAN}===============================${C_RESET}"
  press_any_key_to_continue
}

# 2. 系统更新
function update_system() {
  clear
  echo -e "${C_CYAN}======== 开始更新系统 ========${C_RESET}"
  if command -v apt-get &>/dev/null; then
    sudo apt-get update && sudo apt-get upgrade -y
  elif command -v yum &>/dev/null;
    then
    sudo yum update -y
  else
    echo -e "${C_RED}未知的包管理器，无法自动更新。${C_RESET}"
  fi
  echo -e "${C_GREEN}系统更新完成！${C_RESET}"
  press_any_key_to_continue
}

# ... 其他占位符功能 ...
function ldnmp_setup() {
    echo -e "${C_YELLOW}功能正在开发中...${C_RESET}"
    sleep 1
}

# 安装快捷指令的核心函数 (被自动安装和更新功能调用)
function install_shortcut() {
  # --- 配置 ---
  local script_url="https://raw.githubusercontent.com/wliuy/mypublic/refs/heads/main/Tools"
  local install_name="tools"
  local shortcut_name="y"
  local install_path="/usr/local/bin/${install_name}"
  local shortcut_path="/usr/local/bin/${shortcut_name}"

  # 在非自动安装时（从菜单选择）先清屏
  if [[ "${auto_install}" != "true" ]]; then
    clear
  fi
  
  echo -e "${C_CYAN}开始安装/更新快捷方式 '${shortcut_name}'...${C_RESET}"

  # 1. 检查 root 权限
  if [[ "$(id -u)" -ne 0 ]]; then
    echo -e "${C_RED}错误：此操作需要 root 权限才能写入 /usr/local/bin/${C_RESET}"
    echo -e "${C_YELLOW}请尝试使用 'sudo' 运行此脚本。${C_RESET}"
    press_any_key_to_continue
    return 1 # 返回失败状态码
  fi

  # 2. 下载脚本到 /usr/local/bin
  echo -e "${C_BLUE}正在从 GitHub 下载最新版脚本到 ${install_path}...${C_RESET}"
  if curl -L "${script_url}" -o "${install_path}"; then
    echo -e "${C_GREEN}下载成功！${C_RESET}"
  else
    echo -e "${C_RED}错误：下载脚本失败，请检查网络连接或URL。${C_RESET}"
    press_any_key_to_continue
    return 1 # 返回失败状态码
  fi

  # 3. 添加执行权限
  echo -e "${C_BLUE}正在设置执行权限...${C_RESET}"
  chmod +x "${install_path}"

  # 4. 创建快捷方式的符号链接
  echo -e "${C_BLUE}正在创建快捷命令 '${shortcut_name}' -> '${install_path}'...${C_RESET}"
  ln -sf "${install_path}" "${shortcut_path}"

  # 5. 提示成功信息
  if [[ "${auto_install}" == "true" ]]; then
    echo -e "\n${C_GREEN}🎉 恭喜！快捷方式安装成功！${C_RESET}"
    echo -e "下次登录后, 你就可以在任何地方直接输入 '${C_YELLOW}${shortcut_name}${C_RESET}' 来运行此工具箱了。"
  else
    echo -e "\n${C_GREEN}🎉 恭喜！操作成功！${C_RESET}"
    echo -e "请重新打开一个新的终端窗口, 或执行 ${C_YELLOW}exec $SHELL${C_RESET} 来刷新环境。"
    echo -e "之后, 你就可以在任何地方直接输入 '${C_YELLOW}${shortcut_name}${C_RESET}' 来运行此工具箱了。"
    press_any_key_to_continue
  fi
  
  return 0
}

# 00. 脚本更新
function update_script() {
  clear
  echo -e "${C_CYAN}正在检查并更新脚本...${C_RESET}"
  # 脚本更新逻辑就是重新执行一次安装，用新脚本覆盖旧脚本
  local auto_install="false" # 设置为false，让它显示完整的成功提示和“按任意键继续”
  install_shortcut
}

# 000. 卸载脚本
function uninstall_script() {
  clear
  echo -e "${C_CYAN}开始卸载脚本和快捷方式...${C_RESET}"
  
  local install_name="tools"
  local shortcut_name="y"
  local install_path="/usr/local/bin/${install_name}"
  local shortcut_path="/usr/local/bin/${shortcut_name}"

  # 1. 检查 root 权限
  if [[ "$(id -u)" -ne 0 ]]; then
    echo -e "${C_RED}错误：卸载过程需要 root 权限才能删除 /usr/local/bin/ 中的文件。${C_RESET}"
    press_any_key_to_continue
    return
  fi

  # 2. 检查脚本是否已安装
  if [ ! -f "${install_path}" ] && [ ! -L "${shortcut_path}" ]; then
      echo -e "${C_YELLOW}脚本未安装或文件不存在，无需卸载。${C_RESET}"
      press_any_key_to_continue
      return
  fi

  # 3. 危险操作，要求用户确认
  echo -e "${C_RED}警告：这将从系统中永久删除脚本主体和 '${shortcut_name}' 快捷方式。${C_RESET}"
  read -p "你确定要继续吗？ (输入 'y' 确认, 其他任意键取消): " confirm
  if [[ "${confirm,,}" != "y" ]]; then
      echo -e "\n${C_YELLOW}操作已取消。${C_RESET}"
      press_any_key_to_continue
      return
  fi

  # 4. 执行删除
  echo -e "\n${C_BLUE}正在移除快捷方式: ${shortcut_path}...${C_RESET}"
  rm -f "${shortcut_path}"
  
  echo -e "${C_BLUE}正在移除脚本主体: ${install_path}...${C_RESET}"
  rm -f "${install_path}"

  # 5. 提示成功并退出
  echo -e "\n${C_GREEN}✅ 卸载完成！${C_RESET}"
  echo -e "所有相关文件和快捷方式已被移除。"
  echo -e "脚本即将退出。"
  sleep 3
  exit 0
}

# --- 主菜单显示 ---
function main_menu() {
  clear
  # --- 这里是修改后的标题 ---
  echo -e "${C_CYAN}                                                                    ${C_RESET}"
  echo -e "${C_CYAN}    █████╗ ██╗   ██╗ █████╗ ███╗   ██╗ ██████╗                        ${C_RESET}"
  echo -e "${C_CYAN}   ██╔══██╗╚██╗ ██╔╝██╔══██╗████╗  ██║██╔════╝                        ${C_RESET}"
  echo -e "${C_CYAN}   ███████║ ╚████╔╝ ███████║██╔██╗ ██║██║  ███╗                       ${C_RESET}"
  echo -e "${C_CYAN}   ██╔══██║  ╚██╔╝  ██╔══██║██║╚██╗██║██║   ██║                       ${C_RESET}"
  echo -e "${C_CYAN}   ██║  ██║   ██║   ██║  ██║██║ ╚████║╚██████╔╝                       ${C_RESET}"
  echo -e "${C_CYAN}   ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝                        ${C_RESET}"
  echo -e "${C_CYAN}                                                                    ${C_RESET}"
  echo -e "${C_BLUE}               AYANG's Toolbox v1.0.0               ${C_RESET}"
  echo -e "${C_YELLOW}----------------------------------------------------${C_RESET}"
  echo -e " ${C_GREEN}1.${C_RESET} 系统信息查询           ${C_GREEN}2.${C_RESET} 系统更新"
  # ... 省略部分菜单项 ...
  echo -e " ${C_GREEN}15.${C_RESET} 广告专栏"
  echo -e "${C_YELLOW}----------------------------------------------------${C_RESET}"
  echo -e " ${C_GREEN}00.${C_RESET} 更新脚本              ${C_GREEN}000.${C_RESET} 卸载脚本"
  echo -e " ${C_GREEN}0.${C_RESET}  退出脚本"
  echo -e "${C_YELLOW}----------------------------------------------------${C_RESET}"
  read -p "请输入你的选择: " choice
}

# --- 主循环 ---
function main_loop() {
    while true; do
      main_menu
      case $choice in
      1)
        show_system_info
        ;;
      2)
        update_system
        ;;
      # ... 省略部分 case ...
      00)
        update_script
        ;;
      000)
        uninstall_script
        ;;
      0)
        echo -e "${C_GREEN}感谢使用，再见！${C_RESET}"
        exit 0
        ;;
      *)
        echo -e "${C_RED}无效的输入，请输入菜单中存在的数字选项！${C_RESET}"
        press_any_key_to_continue
        ;;
      esac
    done
}


# ===================================================================================
# --- 脚本主入口逻辑 --- # <--- 这是修改后的新逻辑
# ===================================================================================

readonly INSTALL_PATH="/usr/local/bin/tools"

# 判断脚本是否需要首次安装
if [ ! -f "${INSTALL_PATH}" ]; then
  # 如果 /usr/local/bin/tools 文件不存在, 则执行首次运行的自动安装逻辑
  clear
  echo -e "${C_CYAN}欢迎使用工具箱, 检测到是首次运行。${C_RESET}"
  echo -e "${C_YELLOW}为了方便您未来使用, 脚本将自动为您安装 'y' 快捷指令。${C_RESET}"
  echo -e "安装过程需要 sudo 权限, 如果当前不是root用户, 可能会提示您输入密码。"
  echo -e "---------------------------------------------------------------------"
  
  # 设置一个标记，让安装函数知道这是自动安装
  local auto_install="true"
  
  # 直接调用安装函数, 如果失败则直接进入菜单
  if ! install_shortcut; then
    echo -e "\n${C_RED}自动安装失败, 脚本将进入临时会话模式。${C_RESET}"
    echo -e "${C_YELLOW}您可以继续在本次会话中使用菜单, 但快捷指令 'y' 将不可用。${C_RESET}"
    press_any_key_to_continue
    main_loop 
    exit 1
  fi
  
  # 自动安装成功后，提示并继续进入主菜单
  echo -e "\n${C_GREEN}安装流程执行完毕！${C_RESET}"
  echo -e "${C_YELLOW}正在继续进入主菜单...${C_RESET}"
  sleep 3
fi

# 无论是首次运行安装后, 还是之后直接运行, 最终都会执行主循环
main_loop
